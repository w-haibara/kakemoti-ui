{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { isNumber, isString } from 'element-plus/es/utils/util';\nimport { throwError } from 'element-plus/es/utils/error';\nimport { computed, getCurrentInstance, defineComponent, ref, reactive, watch, onMounted, onBeforeUnmount, h, withModifiers, unref, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport { isObject, hasOwn, isFunction } from '@vue/shared';\nimport isServer from 'element-plus/es/utils/isServer';\nimport memo from 'lodash/memoize';\nimport memoOne from 'memoize-one';\nimport { cAF, rAF } from 'element-plus/es/utils/raf';\nimport { BAR_MAP } from 'element-plus/es/components/scrollbar';\nimport { on, off } from 'element-plus/es/utils/dom';\nimport { buildProp, definePropType, buildProps, mutable } from 'element-plus/es/utils/props';\nimport getScrollBarWidth from 'element-plus/es/utils/scrollbar-width';\n\nconst useCache = () => {\n  const vm = getCurrentInstance();\n  const props = vm.proxy.$props;\n  return computed(() => {\n    const _getItemStyleCache = (_, __, ___) => ({});\n\n    return props.perfMode ? memo(_getItemStyleCache) : memoOne(_getItemStyleCache);\n  });\n};\n\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\n\nconst isHorizontal = dir => dir === LTR || dir === RTL || dir === HORIZONTAL;\n\nconst isRTL = dir => dir === RTL;\n\nlet cachedRTLResult = null;\n\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nfunction renderThumbStyle({\n  move,\n  size,\n  bar\n}, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n\n  return style;\n}\n\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\n\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle;\n  let offset = 0;\n\n  const hasReachedEdge = offset2 => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n\n  const onWheel = e => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset)) return;\n    offset += newOffset;\n\n    if (!isFF) {\n      e.preventDefault();\n    }\n\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nvar __defProp$3 = Object.defineProperty;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$3) for (var prop of __getOwnPropSymbols$3(b)) {\n    if (__propIsEnum$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst itemSize = buildProp({\n  type: definePropType([Number, Function]),\n  required: true\n});\nconst estimatedItemSize = buildProp({\n  type: Number\n});\nconst cache = buildProp({\n  type: Number,\n  default: 2\n});\nconst direction = buildProp({\n  type: String,\n  values: [\"ltr\", \"rtl\"],\n  default: \"ltr\"\n});\nconst initScrollOffset = buildProp({\n  type: Number,\n  default: 0\n});\nconst total = buildProp({\n  type: Number,\n  required: true\n});\nconst layout = buildProp({\n  type: String,\n  values: [\"horizontal\", \"vertical\"],\n  default: VERTICAL\n});\nconst virtualizedProps = buildProps({\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: definePropType([String, Object]),\n    default: \"div\"\n  },\n  data: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  direction,\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  style: {\n    type: definePropType([Object, String, Array])\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  },\n  perfMode: {\n    type: Boolean,\n    default: true\n  }\n});\nconst virtualizedListProps = buildProps(__spreadValues$3({\n  cache,\n  estimatedItemSize,\n  layout,\n  initScrollOffset,\n  total,\n  itemSize\n}, virtualizedProps));\nconst virtualizedGridProps = buildProps(__spreadValues$3({\n  columnCache: cache,\n  columnWidth: itemSize,\n  estimatedColumnWidth: estimatedItemSize,\n  estimatedRowHeight: estimatedItemSize,\n  initScrollLeft: initScrollOffset,\n  initScrollTop: initScrollOffset,\n  rowCache: cache,\n  rowHeight: itemSize,\n  totalColumn: total,\n  totalRow: total\n}, virtualizedProps));\nconst virtualizedScrollbarProps = buildProps({\n  layout,\n  total,\n  ratio: {\n    type: Number,\n    required: true\n  },\n  clientSize: {\n    type: Number,\n    required: true\n  },\n  scrollFrom: {\n    type: Number,\n    required: true\n  },\n  visible: Boolean\n});\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n\n  setup(props, {\n    emit\n  }) {\n    const GAP = 4;\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - GAP);\n    const trackStyle = computed(() => __spreadValues$2({\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }, props.visible ? {} : {\n      display: \"none\"\n    }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      const clientSize = props.clientSize;\n\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - GAP));\n\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = () => false;\n\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    const clickTrackHandler = e => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n\n    const onScrollbarTouchStart = e => e.preventDefault();\n\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onMounted(() => {\n      if (isServer) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n\n});\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const getItemStyleCache = useCache();\n      const windowRef = ref();\n      const innerRef = ref();\n      const scrollbarRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = unref(states);\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, unref(dynamicSizeCache)));\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"hidden\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, {\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style]);\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize);\n        const horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const onScroll = e => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n\n        states.value = __spreadProps$1(__spreadValues$1({}, unref(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, unref(dynamicSizeCache));\n          const horizontal = unref(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = unref(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [listContainer, scrollbar]);\n    }\n\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({\n    itemSize\n  }, index) => index * itemSize,\n  getItemSize: ({\n    itemSize\n  }) => itemSize,\n  getEstimatedTotalSize: ({\n    total,\n    itemSize\n  }) => itemSize * total,\n  getOffset: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n\n    if (process.env.NODE_ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: ({\n    total,\n    itemSize\n  }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n\n  initCache() {\n    return void 0;\n  },\n\n  clearCache: true,\n\n  validateProps() {}\n\n});\nconst SCOPE$2 = \"ElDynamicSizeList\";\n\nconst getItemFromCache$1 = (props, index, listCache) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    listCache.lastVisitedIndex = index;\n  }\n\n  return items[index];\n};\n\nconst findItem$1 = (props, listCache, offset) => {\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedOffset >= offset) {\n    return bs$1(props, listCache, 0, lastVisitedIndex, offset);\n  }\n\n  return es$1(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\n\nconst bs$1 = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, listCache).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n\n  return Math.max(0, low - 1);\n};\n\nconst es$1 = (props, listCache, index, offset) => {\n  const {\n    total\n  } = props;\n  let exponent = 1;\n\n  while (index < total && getItemFromCache$1(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n\n  return bs$1(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\n\nconst getEstimatedTotalSize = ({\n  total\n}, {\n  items,\n  estimatedItemSize,\n  lastVisitedIndex\n}) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache$1(props, index, listCache).offset,\n  getItemSize: (_, index, {\n    items\n  }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const {\n      height,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache$1(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem$1(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const {\n      height,\n      total,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache$1(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, listCache).size;\n    }\n\n    return stopIndex;\n  },\n\n  initCache({\n    estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      var _a, _b;\n\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n\n    return cache;\n  },\n\n  clearCache: false,\n  validateProps: ({\n    itemSize\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE$2, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\n\nconst useGridWheel = ({\n  atXEndEdge,\n  atXStartEdge,\n  atYEndEdge,\n  atYStartEdge\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let xOffset = 0;\n  let yOffset = 0;\n\n  const hasReachedEdge = (x, y) => {\n    const xEdgeReached = x < 0 && atXStartEdge.value || x > 0 && atXEndEdge.value;\n    const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;\n    return xEdgeReached && yEdgeReached;\n  };\n\n  const onWheel = e => {\n    cAF(frameHandle);\n    const x = e.deltaX;\n    const y = e.deltaY;\n    if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x, yOffset + y)) return;\n    xOffset += x;\n    yOffset += y;\n\n    if (!isFF) {\n      e.preventDefault();\n    }\n\n    frameHandle = rAF(() => {\n      onWheelDelta(xOffset, yOffset);\n      xOffset = 0;\n      yOffset = 0;\n    });\n  };\n\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose,\n      slots\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = unref(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = unref(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        let _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = __spreadProps(__spreadValues({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n\n      const {\n        onWheel\n      } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value)\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        const _states = unref(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = __spreadProps(__spreadValues({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n\n        const _cache = unref(cache);\n\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n\n          const _cache = unref(cache);\n\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = unref(windowRef);\n\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n\n      const renderScrollbars = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const {\n          scrollLeft,\n          scrollTop\n        } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n\n      const renderItems = () => {\n        var _a;\n\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const {\n          data,\n          totalColumn,\n          totalRow,\n          useIsScrolling\n        } = props;\n        const children = [];\n\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: column,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n\n        return children;\n      };\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          default: () => children\n        } : children)];\n      };\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const {\n          horizontalScrollbar,\n          verticalScrollbar\n        } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: \"el-vg__wrapper\"\n        }, [h(Container, {\n          class: props.className,\n          style: unref(windowStyle),\n          onScroll,\n          onWheel,\n          ref: windowRef\n        }, !isString(Container) ? {\n          default: () => Inner\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n\n      return renderWindow;\n    }\n\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(width / 2)) {\n            return 0;\n          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n            return lastColumnOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(height / 2)) {\n            return 0;\n          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n            return lastRowOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\n\nconst getItemFromCache = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n\n  if (index > lastVisited) {\n    let offset = 0;\n\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n\n  return cachedItems[index];\n};\n\nconst bs = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return max(0, low - 1);\n};\n\nconst es = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\n\nconst findItem = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\n\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\n\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\n\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\n\nconst FixedSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid$1 as FixedSizeGrid, FixedSizeList, virtualizedGridProps, virtualizedListProps, virtualizedProps, virtualizedScrollbarProps };","map":{"version":3,"names":["isNumber","isString","throwError","computed","getCurrentInstance","defineComponent","ref","reactive","watch","onMounted","onBeforeUnmount","h","withModifiers","unref","onUpdated","resolveDynamicComponent","nextTick","isObject","hasOwn","isFunction","isServer","memo","memoOne","cAF","rAF","BAR_MAP","on","off","buildProp","definePropType","buildProps","mutable","getScrollBarWidth","useCache","vm","props","proxy","$props","_getItemStyleCache","_","__","___","perfMode","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","ITEM_RENDER_EVT","SCROLL_EVT","FORWARD","BACKWARD","AUTO_ALIGNMENT","SMART_ALIGNMENT","START_ALIGNMENT","CENTERED_ALIGNMENT","END_ALIGNMENT","HORIZONTAL","VERTICAL","LTR","RTL","RTL_OFFSET_NAG","RTL_OFFSET_POS_ASC","RTL_OFFSET_POS_DESC","ScrollbarDirKey","SCROLLBAR_MIN_SIZE","getScrollDir","prev","cur","isHorizontal","dir","isRTL","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","renderThumbStyle","move","size","bar","layout","translate","axis","transform","msTransform","webkitTransform","isFF","navigator","test","userAgent","LayoutKeys","useWheel","atEndEdge","atStartEdge","onWheelDelta","frameHandle","offset","hasReachedEdge","offset2","edgeReached","value","onWheel","e","newOffset","preventDefault","__defProp$3","Object","defineProperty","__getOwnPropSymbols$3","getOwnPropertySymbols","__hasOwnProp$3","prototype","hasOwnProperty","__propIsEnum$3","propertyIsEnumerable","__defNormalProp$3","obj","key","enumerable","configurable","writable","__spreadValues$3","a","b","prop","call","itemSize","type","Number","Function","required","estimatedItemSize","cache","default","String","values","initScrollOffset","total","virtualizedProps","className","containerElement","data","Array","innerElement","useIsScrolling","Boolean","virtualizedListProps","virtualizedGridProps","columnCache","columnWidth","estimatedColumnWidth","estimatedRowHeight","initScrollLeft","initScrollTop","rowCache","rowHeight","totalColumn","totalRow","virtualizedScrollbarProps","ratio","clientSize","scrollFrom","visible","__defProp$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","ScrollBar","name","emits","setup","emit","GAP","trackRef","thumbRef","onselectstartStore","state","isDragging","traveled","trackSize","trackStyle","position","right","bottom","borderRadius","display","thumbSize","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","thumbStyle","isFinite","thumb","totalSteps","attachEvents","window","onMouseMove","onMouseUp","thumbEl","onselectstart","detachEvents","onThumbMouseDown","stopImmediatePropagation","ctrlKey","includes","button","currentTarget","client","getBoundingClientRect","prevPage","thumbClickPosition","distance","clickTrackHandler","abs","target","thumbHalf","onScrollbarTouchStart","v","ceil","role","class","onMousedown","__defProp$1","__defProps$1","defineProperties","__getOwnPropDescs$1","getOwnPropertyDescriptors","__getOwnPropSymbols$1","__hasOwnProp$1","__propIsEnum$1","__defNormalProp$1","__spreadValues$1","__spreadProps$1","createList","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","expose","instance","dynamicSizeCache","getItemStyleCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","updateRequested","isScrollbarDragging","itemsToRender","startIndex","stopIndex","cacheBackward","cacheForward","estimatedTotalSize","_isHorizontal","windowStyle","WebkitOverflowScrolling","willChange","horizontal","pointerEvents","_a","_b","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","clientHeight","scrollHeight","scrollTop","_states","resetIsScrolling","scrollHorizontally","clientWidth","scrollWidth","onScroll","onScrollbarScroll","distanceToGo","scrollToItem","idx","alignment","getItemStyle","itemStyleCache","isRtl","offsetHorizontal","left","top","resetScrollTop","windowElement","api","render","ctx","$slots","start","end","Container","Inner","children","i","push","index","InnerNode","scrollbar","listContainer","FixedSizeList","process","env","NODE_ENV","lastItemOffset","maxOffset","minOffset","middleOffset","round","numVisibleItems","SCOPE$2","getItemFromCache$1","listCache","items","lastVisitedIndex","item","findItem$1","lastVisitedOffset","bs$1","es$1","low","high","mid","currentOffset","exponent","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","clearCacheAfterIndex","forceUpdate","exposed","$forceUpdate","useGridWheel","atXEndEdge","atXStartEdge","atYEndEdge","atYStartEdge","xOffset","yOffset","x","y","xEdgeReached","yEdgeReached","deltaX","deltaY","__defProp","__defProps","__getOwnPropDescs","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","__spreadValues","__spreadProps","createGrid","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","slots","hScrollbar","vScrollbar","xAxisScrollDir","yAxisScrollDir","parsedHeight","parseInt","parsedWidth","columnsToRender","rowsToRender","estimatedTotalHeight","estimatedTotalWidth","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","_scrollLeft","onVerticalScroll","onHorizontalScroll","_c","_d","rowIndex","columnIdx","scrollBarWidth","_cache","estimatedHeight","estimatedWidth","columnIndex","rtl","renderScrollbars","horizontalScrollbar","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","row","column","renderInner","renderWindow","SCOPE$1","FixedSizeGrid$1","lastColumnOffset","align","lastRowOffset","visibleColumnsCount","numVisibleRows","SCOPE","ACCESS_SIZER_KEY_MAP","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","gridCache","cachedItems","sizer","lastVisited","bs","es","findItem","lastVisitedItemOffset","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","estimatedSizeAssociates","estimatedSize","FixedSizeGrid","DynamicSizeGrid"],"sources":["/home/haibara/ghq/github.com/w-haibara/kakemoti-ui/node_modules/element-plus/es/components/virtual-list/index.js"],"sourcesContent":["import { isNumber, isString } from 'element-plus/es/utils/util';\nimport { throwError } from 'element-plus/es/utils/error';\nimport { computed, getCurrentInstance, defineComponent, ref, reactive, watch, onMounted, onBeforeUnmount, h, withModifiers, unref, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport { isObject, hasOwn, isFunction } from '@vue/shared';\nimport isServer from 'element-plus/es/utils/isServer';\nimport memo from 'lodash/memoize';\nimport memoOne from 'memoize-one';\nimport { cAF, rAF } from 'element-plus/es/utils/raf';\nimport { BAR_MAP } from 'element-plus/es/components/scrollbar';\nimport { on, off } from 'element-plus/es/utils/dom';\nimport { buildProp, definePropType, buildProps, mutable } from 'element-plus/es/utils/props';\nimport getScrollBarWidth from 'element-plus/es/utils/scrollbar-width';\n\nconst useCache = () => {\n  const vm = getCurrentInstance();\n  const props = vm.proxy.$props;\n  return computed(() => {\n    const _getItemStyleCache = (_, __, ___) => ({});\n    return props.perfMode ? memo(_getItemStyleCache) : memoOne(_getItemStyleCache);\n  });\n};\n\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\nconst isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;\nconst isRTL = (dir) => dir === RTL;\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n  return cachedRTLResult;\n}\nfunction renderThumbStyle({ move, size, bar }, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n  return style;\n}\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\n\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\nconst useWheel = ({ atEndEdge, atStartEdge, layout }, onWheelDelta) => {\n  let frameHandle;\n  let offset = 0;\n  const hasReachedEdge = (offset2) => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n  const onWheel = (e) => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))\n      return;\n    offset += newOffset;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nvar __defProp$3 = Object.defineProperty;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nconst itemSize = buildProp({\n  type: definePropType([Number, Function]),\n  required: true\n});\nconst estimatedItemSize = buildProp({\n  type: Number\n});\nconst cache = buildProp({\n  type: Number,\n  default: 2\n});\nconst direction = buildProp({\n  type: String,\n  values: [\"ltr\", \"rtl\"],\n  default: \"ltr\"\n});\nconst initScrollOffset = buildProp({\n  type: Number,\n  default: 0\n});\nconst total = buildProp({\n  type: Number,\n  required: true\n});\nconst layout = buildProp({\n  type: String,\n  values: [\"horizontal\", \"vertical\"],\n  default: VERTICAL\n});\nconst virtualizedProps = buildProps({\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: definePropType([String, Object]),\n    default: \"div\"\n  },\n  data: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  direction,\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  style: {\n    type: definePropType([Object, String, Array])\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  },\n  perfMode: {\n    type: Boolean,\n    default: true\n  }\n});\nconst virtualizedListProps = buildProps(__spreadValues$3({\n  cache,\n  estimatedItemSize,\n  layout,\n  initScrollOffset,\n  total,\n  itemSize\n}, virtualizedProps));\nconst virtualizedGridProps = buildProps(__spreadValues$3({\n  columnCache: cache,\n  columnWidth: itemSize,\n  estimatedColumnWidth: estimatedItemSize,\n  estimatedRowHeight: estimatedItemSize,\n  initScrollLeft: initScrollOffset,\n  initScrollTop: initScrollOffset,\n  rowCache: cache,\n  rowHeight: itemSize,\n  totalColumn: total,\n  totalRow: total\n}, virtualizedProps));\nconst virtualizedScrollbarProps = buildProps({\n  layout,\n  total,\n  ratio: {\n    type: Number,\n    required: true\n  },\n  clientSize: {\n    type: Number,\n    required: true\n  },\n  scrollFrom: {\n    type: Number,\n    required: true\n  },\n  visible: Boolean\n});\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, { emit }) {\n    const GAP = 4;\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - GAP);\n    const trackStyle = computed(() => __spreadValues$2({\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }, props.visible ? {} : { display: \"none\" }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      const clientSize = props.clientSize;\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - GAP));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl)\n        return;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl)\n        return;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = (e) => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = (e) => {\n      const { isDragging } = state;\n      if (!isDragging)\n        return;\n      if (!thumbRef.value || !trackRef.value)\n        return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage)\n        return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const clickTrackHandler = (e) => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n    const onScrollbarTouchStart = (e) => e.preventDefault();\n    watch(() => props.scrollFrom, (v) => {\n      if (state.isDragging)\n        return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onMounted(() => {\n      if (isServer)\n        return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n});\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const getItemStyleCache = useCache();\n      const windowRef = ref();\n      const innerRef = ref();\n      const scrollbarRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const { total, cache } = props;\n        const { isScrolling, scrollDir, scrollOffset } = unref(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, unref(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        },\n        props.style\n      ]);\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize);\n        const horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const { onWheel } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, (offset) => {\n        var _a, _b;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const { total } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const { scrollDir, scrollOffset, updateRequested } = unref(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = (e) => {\n        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = (e) => {\n        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const { direction } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft;\n              break;\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n            }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = (e) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const scrollTo = (offset) => {\n        offset = Math.max(offset, 0);\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n        states.value = __spreadProps$1(__spreadValues$1({}, unref(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const { scrollOffset } = unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n      const getItemStyle = (idx) => {\n        const { direction, itemSize, layout } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, unref(dynamicSizeCache));\n          const horizontal = unref(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollOffset } = props;\n        const windowElement = unref(windowRef);\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction, layout } = props;\n        const { scrollOffset, updateRequested } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\": {\n                  windowElement.scrollLeft = -scrollOffset;\n                  break;\n                }\n                case \"positive-ascending\": {\n                  windowElement.scrollLeft = scrollOffset;\n                  break;\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                  break;\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [\n        h(Inner, {\n          style: innerStyle,\n          ref: \"innerRef\"\n        }, !isString(Inner) ? {\n          default: () => children\n        } : children)\n      ];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({ itemSize }, index) => index * itemSize,\n  getItemSize: ({ itemSize }) => itemSize,\n  getEstimatedTotalSize: ({ total, itemSize }) => itemSize * total,\n  getOffset: ({ height, total, itemSize, layout, width }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.NODE_ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0;\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: ({ total, itemSize }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({ height, total, itemSize, layout, width }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {\n  }\n});\n\nconst SCOPE$2 = \"ElDynamicSizeList\";\nconst getItemFromCache$1 = (props, index, listCache) => {\n  const { itemSize } = props;\n  const { items, lastVisitedIndex } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem$1 = (props, listCache, offset) => {\n  const { items, lastVisitedIndex } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs$1(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es$1(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs$1 = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es$1 = (props, listCache, index, offset) => {\n  const { total } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache$1(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs$1(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({ total }, { items, estimatedItemSize, lastVisitedIndex }) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache$1(props, index, listCache).offset,\n  getItemSize: (_, index, { items }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache$1(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem$1(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache$1(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      var _a, _b;\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE$2, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\n\nconst useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {\n  let frameHandle = null;\n  let xOffset = 0;\n  let yOffset = 0;\n  const hasReachedEdge = (x, y) => {\n    const xEdgeReached = x < 0 && atXStartEdge.value || x > 0 && atXEndEdge.value;\n    const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;\n    return xEdgeReached && yEdgeReached;\n  };\n  const onWheel = (e) => {\n    cAF(frameHandle);\n    const x = e.deltaX;\n    const y = e.deltaY;\n    if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x, yOffset + y))\n      return;\n    xOffset += x;\n    yOffset += y;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(xOffset, yOffset);\n      xOffset = 0;\n      yOffset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props;\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props;\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n        return [\n          {\n            position: \"relative\",\n            overflow: \"hidden\",\n            WebkitOverflowScrolling: \"touch\",\n            willChange: \"transform\"\n          },\n          {\n            direction: props.direction,\n            height: isNumber(props.height) ? `${props.height}px` : props.height,\n            width: isNumber(props.width) ? `${props.width}px` : props.width\n          },\n          (_a = props.style) != null ? _a : {}\n        ];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd\n          ] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = (e) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = __spreadProps(__spreadValues({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      const { onWheel } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value)\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = __spreadProps(__spreadValues({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n        const _cache = unref(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const { columnWidth, direction, rowHeight } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n          const _cache = unref(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollLeft, initScrollTop } = props;\n        const windowElement = unref(windowRef);\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction } = props;\n        const { scrollLeft, scrollTop, updateRequested } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft;\n                break;\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft;\n                break;\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement;\n                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      const renderScrollbars = () => {\n        const { totalColumn, totalRow } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const { scrollLeft, scrollTop } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n      const renderItems = () => {\n        var _a;\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const { data, totalColumn, totalRow, useIsScrolling } = props;\n        const children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: column,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n        return children;\n      };\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [\n          h(Inner, {\n            style: unref(innerStyle),\n            ref: innerRef\n          }, !isString(Inner) ? {\n            default: () => children\n          } : children)\n        ];\n      };\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: \"el-vg__wrapper\"\n        }, [\n          h(Container, {\n            class: props.className,\n            style: unref(windowStyle),\n            onScroll,\n            onWheel,\n            ref: windowRef\n          }, !isString(Container) ? { default: () => Inner } : Inner),\n          horizontalScrollbar,\n          verticalScrollbar\n        ]);\n      };\n      return renderWindow;\n    }\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth,\n    index * columnWidth\n  ],\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight,\n    index * rowHeight\n  ],\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,\n  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nconst { max, min, floor } = Math;\nconst SCOPE = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [\n    type === \"row\" ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]\n  ];\n  const item = getItemFromCache(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset;\n    }\n    case END_ALIGNMENT: {\n      return minOffset;\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n};\nconst FixedSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props;\n    const item = getItemFromCache(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nexport { FixedSizeGrid as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid$1 as FixedSizeGrid, FixedSizeList, virtualizedGridProps, virtualizedListProps, virtualizedProps, virtualizedScrollbarProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}