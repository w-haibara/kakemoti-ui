{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { withInstall } from 'element-plus/es/utils/with-install';\nimport { defineComponent, shallowRef, reactive, computed, watch, onMounted, openBlock, createElementBlock, normalizeStyle, createElementVNode, normalizeClass, renderSlot } from 'vue';\nimport { useEventListener, useResizeObserver } from '@vueuse/core';\nimport { getScrollContainer } from 'element-plus/es/utils/dom';\nimport { buildProps, definePropType } from 'element-plus/es/utils/props';\nconst affixProps = buildProps({\n  zIndex: {\n    type: definePropType([Number, String]),\n    default: 100\n  },\n  target: {\n    type: String,\n    default: \"\"\n  },\n  offset: {\n    type: Number,\n    default: 0\n  },\n  position: {\n    type: String,\n    values: [\"top\", \"bottom\"],\n    default: \"top\"\n  }\n});\nconst affixEmits = {\n  scroll: ({\n    scrollTop,\n    fixed\n  }) => typeof scrollTop === \"number\" && typeof fixed === \"boolean\",\n  change: fixed => typeof fixed === \"boolean\"\n};\nvar script = defineComponent({\n  name: \"ElAffix\",\n  props: affixProps,\n  emits: affixEmits,\n\n  setup(props, {\n    emit\n  }) {\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const state = reactive({\n      fixed: false,\n      height: 0,\n      width: 0,\n      scrollTop: 0,\n      clientHeight: 0,\n      transform: 0\n    });\n    const rootStyle = computed(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : \"\",\n        width: state.fixed ? `${state.width}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!state.fixed) return;\n      const offset = props.offset ? `${props.offset}px` : 0;\n      const transform = state.transform ? `translateY(${state.transform}px)` : \"\";\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform,\n        zIndex: props.zIndex\n      };\n    });\n\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return;\n      const rootRect = root.value.getBoundingClientRect();\n      const targetRect = target.value.getBoundingClientRect();\n      state.height = rootRect.height;\n      state.width = rootRect.width;\n      state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;\n      state.clientHeight = document.documentElement.clientHeight;\n\n      if (props.position === \"top\") {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height;\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;\n          state.transform = difference < 0 ? difference : 0;\n        } else {\n          state.fixed = props.offset > rootRect.top;\n        }\n      } else {\n        if (props.target) {\n          const difference = state.clientHeight - targetRect.top - props.offset - state.height;\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;\n          state.transform = difference < 0 ? -difference : 0;\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom;\n        }\n      }\n    };\n\n    const onScroll = () => {\n      update();\n      emit(\"scroll\", {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed\n      });\n    };\n\n    watch(() => state.fixed, () => {\n      emit(\"change\", state.fixed);\n    });\n    onMounted(() => {\n      var _a;\n\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`);\n        }\n      } else {\n        target.value = document.documentElement;\n      }\n\n      scrollContainer.value = getScrollContainer(root.value, true);\n    });\n    useEventListener(scrollContainer, \"scroll\", onScroll);\n    useResizeObserver(root, () => update());\n    return {\n      root,\n      state,\n      rootStyle,\n      affixStyle\n    };\n  }\n\n});\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"root\",\n    class: \"el-affix\",\n    style: normalizeStyle(_ctx.rootStyle)\n  }, [createElementVNode(\"div\", {\n    class: normalizeClass({\n      \"el-affix--fixed\": _ctx.state.fixed\n    }),\n    style: normalizeStyle(_ctx.affixStyle)\n  }, [renderSlot(_ctx.$slots, \"default\")], 6)], 4);\n}\n\nscript.render = render;\nscript.__file = \"packages/components/affix/src/affix.vue\";\nconst ElAffix = withInstall(script);\nexport { ElAffix, affixEmits, affixProps, ElAffix as default };","map":{"version":3,"names":["withInstall","defineComponent","shallowRef","reactive","computed","watch","onMounted","openBlock","createElementBlock","normalizeStyle","createElementVNode","normalizeClass","renderSlot","useEventListener","useResizeObserver","getScrollContainer","buildProps","definePropType","affixProps","zIndex","type","Number","String","default","target","offset","position","values","affixEmits","scroll","scrollTop","fixed","change","script","name","props","emits","setup","emit","root","scrollContainer","state","height","width","clientHeight","transform","rootStyle","affixStyle","top","bottom","update","value","rootRect","getBoundingClientRect","targetRect","Window","document","documentElement","difference","onScroll","_a","querySelector","Error","render","_ctx","_cache","$props","$setup","$data","$options","ref","class","style","$slots","__file","ElAffix"],"sources":["/home/haibara/ghq/github.com/w-haibara/kakemoti-ui/node_modules/element-plus/es/components/affix/index.js"],"sourcesContent":["import { withInstall } from 'element-plus/es/utils/with-install';\nimport { defineComponent, shallowRef, reactive, computed, watch, onMounted, openBlock, createElementBlock, normalizeStyle, createElementVNode, normalizeClass, renderSlot } from 'vue';\nimport { useEventListener, useResizeObserver } from '@vueuse/core';\nimport { getScrollContainer } from 'element-plus/es/utils/dom';\nimport { buildProps, definePropType } from 'element-plus/es/utils/props';\n\nconst affixProps = buildProps({\n  zIndex: {\n    type: definePropType([Number, String]),\n    default: 100\n  },\n  target: {\n    type: String,\n    default: \"\"\n  },\n  offset: {\n    type: Number,\n    default: 0\n  },\n  position: {\n    type: String,\n    values: [\"top\", \"bottom\"],\n    default: \"top\"\n  }\n});\nconst affixEmits = {\n  scroll: ({ scrollTop, fixed }) => typeof scrollTop === \"number\" && typeof fixed === \"boolean\",\n  change: (fixed) => typeof fixed === \"boolean\"\n};\n\nvar script = defineComponent({\n  name: \"ElAffix\",\n  props: affixProps,\n  emits: affixEmits,\n  setup(props, { emit }) {\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const state = reactive({\n      fixed: false,\n      height: 0,\n      width: 0,\n      scrollTop: 0,\n      clientHeight: 0,\n      transform: 0\n    });\n    const rootStyle = computed(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : \"\",\n        width: state.fixed ? `${state.width}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!state.fixed)\n        return;\n      const offset = props.offset ? `${props.offset}px` : 0;\n      const transform = state.transform ? `translateY(${state.transform}px)` : \"\";\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform,\n        zIndex: props.zIndex\n      };\n    });\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value)\n        return;\n      const rootRect = root.value.getBoundingClientRect();\n      const targetRect = target.value.getBoundingClientRect();\n      state.height = rootRect.height;\n      state.width = rootRect.width;\n      state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;\n      state.clientHeight = document.documentElement.clientHeight;\n      if (props.position === \"top\") {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height;\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;\n          state.transform = difference < 0 ? difference : 0;\n        } else {\n          state.fixed = props.offset > rootRect.top;\n        }\n      } else {\n        if (props.target) {\n          const difference = state.clientHeight - targetRect.top - props.offset - state.height;\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;\n          state.transform = difference < 0 ? -difference : 0;\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom;\n        }\n      }\n    };\n    const onScroll = () => {\n      update();\n      emit(\"scroll\", {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed\n      });\n    };\n    watch(() => state.fixed, () => {\n      emit(\"change\", state.fixed);\n    });\n    onMounted(() => {\n      var _a;\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`);\n        }\n      } else {\n        target.value = document.documentElement;\n      }\n      scrollContainer.value = getScrollContainer(root.value, true);\n    });\n    useEventListener(scrollContainer, \"scroll\", onScroll);\n    useResizeObserver(root, () => update());\n    return {\n      root,\n      state,\n      rootStyle,\n      affixStyle\n    };\n  }\n});\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"root\",\n    class: \"el-affix\",\n    style: normalizeStyle(_ctx.rootStyle)\n  }, [\n    createElementVNode(\"div\", {\n      class: normalizeClass({ \"el-affix--fixed\": _ctx.state.fixed }),\n      style: normalizeStyle(_ctx.affixStyle)\n    }, [\n      renderSlot(_ctx.$slots, \"default\")\n    ], 6)\n  ], 4);\n}\n\nscript.render = render;\nscript.__file = \"packages/components/affix/src/affix.vue\";\n\nconst ElAffix = withInstall(script);\n\nexport { ElAffix, affixEmits, affixProps, ElAffix as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}