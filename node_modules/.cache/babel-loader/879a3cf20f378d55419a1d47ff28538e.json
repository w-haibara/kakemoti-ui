{"ast":null,"code":"import { nextTick } from 'vue';\nimport { isFunction } from '@vue/shared';\nimport throttle from 'lodash/throttle';\nimport { getScrollContainer, getOffsetTopDistance } from 'element-plus/es/utils/dom';\nimport { throwError } from 'element-plus/es/utils/error';\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nconst SCOPE = \"ElInfiniteScroll\";\nconst CHECK_INTERVAL = 50;\nconst DEFAULT_DELAY = 200;\nconst DEFAULT_DISTANCE = 0;\nconst attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\n\nconst getScrollOptions = (el, instance) => {\n  return Object.entries(attributes).reduce((acm, [name, option]) => {\n    var _a, _b;\n\n    const {\n      type,\n      default: defaultValue\n    } = option;\n    const attrVal = el.getAttribute(`infinite-scroll-${name}`);\n    let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\n\nconst destroyObserver = el => {\n  const {\n    observer\n  } = el[SCOPE];\n\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\n\nconst handleScroll = (el, cb) => {\n  const {\n    container,\n    containerEl,\n    instance,\n    observer,\n    lastScrollTop\n  } = el[SCOPE];\n  const {\n    disabled,\n    distance\n  } = getScrollOptions(el, instance);\n  const {\n    clientHeight,\n    scrollHeight,\n    scrollTop\n  } = containerEl;\n  const delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0) return;\n  let shouldTrigger = false;\n\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    const {\n      clientTop,\n      scrollHeight: height\n    } = el;\n    const offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\n\nfunction checkFull(el, cb) {\n  const {\n    containerEl,\n    instance\n  } = el[SCOPE];\n  const {\n    disabled\n  } = getScrollOptions(el, instance);\n  if (disabled) return;\n\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\n\nconst InfiniteScroll = {\n  mounted(el, binding) {\n    return __async(this, null, function* () {\n      const {\n        instance,\n        value: cb\n      } = binding;\n\n      if (!isFunction(cb)) {\n        throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n      }\n\n      yield nextTick();\n      const {\n        delay,\n        immediate\n      } = getScrollOptions(el, instance);\n      const container = getScrollContainer(el, true);\n      const containerEl = container === window ? document.documentElement : container;\n      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n      if (!container) return;\n      el[SCOPE] = {\n        instance,\n        container,\n        containerEl,\n        delay,\n        cb,\n        onScroll,\n        lastScrollTop: containerEl.scrollTop\n      };\n\n      if (immediate) {\n        const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n        el[SCOPE].observer = observer;\n        observer.observe(el, {\n          childList: true,\n          subtree: true\n        });\n        checkFull(el, cb);\n      }\n\n      container.addEventListener(\"scroll\", onScroll);\n    });\n  },\n\n  unmounted(el) {\n    const {\n      container,\n      onScroll\n    } = el[SCOPE];\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n\n};\nconst _InfiniteScroll = InfiniteScroll;\n\n_InfiniteScroll.install = app => {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\n\nconst ElInfiniteScroll = _InfiniteScroll;\nexport { ElInfiniteScroll, _InfiniteScroll as default };","map":{"version":3,"names":["nextTick","isFunction","throttle","getScrollContainer","getOffsetTopDistance","throwError","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","throw","x","done","then","apply","SCOPE","CHECK_INTERVAL","DEFAULT_DELAY","DEFAULT_DISTANCE","attributes","delay","type","Number","default","distance","disabled","Boolean","immediate","getScrollOptions","el","instance","Object","entries","reduce","acm","name","option","_a","_b","defaultValue","attrVal","getAttribute","isNaN","destroyObserver","observer","disconnect","handleScroll","cb","container","containerEl","lastScrollTop","clientHeight","scrollHeight","scrollTop","delta","shouldTrigger","clientTop","height","offsetTop","call","checkFull","InfiniteScroll","mounted","binding","window","document","documentElement","onScroll","bind","MutationObserver","observe","childList","subtree","addEventListener","unmounted","removeEventListener","_InfiniteScroll","install","app","directive","ElInfiniteScroll"],"sources":["/home/haibara/ghq/github.com/w-haibara/kakemoti-ui/node_modules/element-plus/es/components/infinite-scroll/index.js"],"sourcesContent":["import { nextTick } from 'vue';\nimport { isFunction } from '@vue/shared';\nimport throttle from 'lodash/throttle';\nimport { getScrollContainer, getOffsetTopDistance } from 'element-plus/es/utils/dom';\nimport { throwError } from 'element-plus/es/utils/error';\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst SCOPE = \"ElInfiniteScroll\";\nconst CHECK_INTERVAL = 50;\nconst DEFAULT_DELAY = 200;\nconst DEFAULT_DISTANCE = 0;\nconst attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\nconst getScrollOptions = (el, instance) => {\n  return Object.entries(attributes).reduce((acm, [name, option]) => {\n    var _a, _b;\n    const { type, default: defaultValue } = option;\n    const attrVal = el.getAttribute(`infinite-scroll-${name}`);\n    let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\nconst destroyObserver = (el) => {\n  const { observer } = el[SCOPE];\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\nconst handleScroll = (el, cb) => {\n  const { container, containerEl, instance, observer, lastScrollTop } = el[SCOPE];\n  const { disabled, distance } = getScrollOptions(el, instance);\n  const { clientHeight, scrollHeight, scrollTop } = containerEl;\n  const delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0)\n    return;\n  let shouldTrigger = false;\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    const { clientTop, scrollHeight: height } = el;\n    const offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\nfunction checkFull(el, cb) {\n  const { containerEl, instance } = el[SCOPE];\n  const { disabled } = getScrollOptions(el, instance);\n  if (disabled)\n    return;\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\nconst InfiniteScroll = {\n  mounted(el, binding) {\n    return __async(this, null, function* () {\n      const { instance, value: cb } = binding;\n      if (!isFunction(cb)) {\n        throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n      }\n      yield nextTick();\n      const { delay, immediate } = getScrollOptions(el, instance);\n      const container = getScrollContainer(el, true);\n      const containerEl = container === window ? document.documentElement : container;\n      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n      if (!container)\n        return;\n      el[SCOPE] = {\n        instance,\n        container,\n        containerEl,\n        delay,\n        cb,\n        onScroll,\n        lastScrollTop: containerEl.scrollTop\n      };\n      if (immediate) {\n        const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n        el[SCOPE].observer = observer;\n        observer.observe(el, { childList: true, subtree: true });\n        checkFull(el, cb);\n      }\n      container.addEventListener(\"scroll\", onScroll);\n    });\n  },\n  unmounted(el) {\n    const { container, onScroll } = el[SCOPE];\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n};\n\nconst _InfiniteScroll = InfiniteScroll;\n_InfiniteScroll.install = (app) => {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\nconst ElInfiniteScroll = _InfiniteScroll;\n\nexport { ElInfiniteScroll, _InfiniteScroll as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}